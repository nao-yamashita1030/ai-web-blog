# ビジネスロジック設計

## 4.1 ビジネスルール

### 記事表示ルール

#### ルール名: 公開記事のみ表示
- **内容**: publishedAtが設定されている記事のみを表示する
- **適用範囲**: 記事一覧、記事詳細、検索結果

#### ルール名: 最新順表示
- **内容**: 記事一覧は公開日時の降順（最新順）で表示する
- **適用範囲**: トップページ、カテゴリページ、タグページ

#### ルール名: ページネーション
- **内容**: 1ページあたり10〜20件の記事を表示する
- **適用範囲**: 記事一覧ページ

### 検索ルール

#### ルール名: 全文検索
- **内容**: タイトル、本文、カテゴリ名、タグ名を対象に検索する
- **適用範囲**: 検索機能

#### ルール名: 部分一致検索
- **内容**: 検索クエリが含まれる記事を検索する（部分一致）
- **適用範囲**: 検索機能

#### ルール名: 大文字小文字を区別しない
- **内容**: 検索時に大文字小文字を区別しない
- **適用範囲**: 検索機能

### カテゴリ・タグルール

#### ルール名: 1記事に1カテゴリ
- **内容**: 1つの記事には1つのカテゴリのみ設定可能
- **適用範囲**: 記事管理（microCMS側）

#### ルール名: 1記事に複数タグ
- **内容**: 1つの記事には複数のタグを設定可能
- **適用範囲**: 記事管理（microCMS側）

## 4.2 ビジネスロジック詳細

### 記事一覧取得ロジック

#### 目的
公開されている記事を最新順で取得する

#### 入力
- `limit?: number` - 取得件数（デフォルト: 10）
- `offset?: number` - オフセット（デフォルト: 0）
- `categorySlug?: string` - カテゴリスラッグ（オプション）
- `tagSlug?: string` - タグスラッグ（オプション）

#### 処理
1. microCMS APIから記事一覧を取得
2. publishedAtが設定されている記事のみをフィルタ
3. publishedAtの降順でソート
4. カテゴリスラッグが指定されている場合、該当カテゴリの記事のみをフィルタ
5. タグスラッグが指定されている場合、該当タグの記事のみをフィルタ
6. limitとoffsetを適用してページネーション

#### 出力
- `Blog[]` - 記事配列
- `totalCount: number` - 総件数

#### 例外処理
- API接続エラー: エラーをスロー
- データ取得エラー: エラーをスロー

### 記事詳細取得ロジック

#### 目的
指定されたIDの記事詳細を取得する

#### 入力
- `id: string` - 記事ID

#### 処理
1. microCMS APIから記事詳細を取得
2. publishedAtが設定されているか確認
3. 設定されていない場合は404エラーを返す

#### 出力
- `Blog` - 記事データ

#### 例外処理
- 記事が見つからない: 404エラーを返す
- API接続エラー: エラーをスロー

### 検索ロジック

#### 目的
記事データから検索クエリに一致する記事を検索する

#### 入力
- `blogs: Blog[]` - 検索対象の記事配列
- `query: string` - 検索クエリ

#### 処理
1. 検索クエリを正規化（トリム、小文字変換）
2. 各記事について以下をチェック:
   - タイトルに検索クエリが含まれるか
   - 本文に検索クエリが含まれるか
   - カテゴリ名に検索クエリが含まれるか
   - タグ名に検索クエリが含まれるか
3. いずれかに一致する記事を結果に追加
4. 公開日時の降順でソート

#### 出力
- `Blog[]` - 検索結果の記事配列

#### 例外処理
- 検索クエリが空: 空配列を返す
- 検索対象が空: 空配列を返す

### ページネーションロジック

#### 目的
記事配列をページ単位に分割する

#### 入力
- `items: T[]` - 分割対象の配列
- `page: number` - 現在のページ番号（1から開始）
- `perPage: number` - 1ページあたりの件数

#### 処理
1. 総ページ数を計算: `Math.ceil(items.length / perPage)`
2. オフセットを計算: `(page - 1) * perPage`
3. 配列をスライス: `items.slice(offset, offset + perPage)`

#### 出力
- `{ items: T[], totalPages: number }` - ページネーション結果

#### 例外処理
- ページ番号が範囲外: 空配列を返す
- perPageが0以下: エラーをスロー

### マークダウン解析ロジック

#### 目的
マークダウン文字列をHTMLに変換する

#### 入力
- `content: string` - マークダウン文字列

#### 処理
1. react-markdownライブラリを使用
2. マークダウンをHTMLに変換
3. コードブロックのシンタックスハイライトを適用（オプション）
4. 画像の最適化を適用

#### 出力
- `ReactNode` - HTMLコンテンツ

#### 例外処理
- マークダウンが不正: エラーメッセージを表示
- 解析エラー: エラーメッセージを表示

## 4.3 計算ロジック

### ページネーション計算

#### 計算式
```
totalPages = Math.ceil(totalItems / perPage)
offset = (currentPage - 1) * perPage
startIndex = offset
endIndex = offset + perPage
```

#### 入力
- `totalItems: number` - 総件数
- `currentPage: number` - 現在のページ番号
- `perPage: number` - 1ページあたりの件数

#### 出力
- `totalPages: number` - 総ページ数
- `offset: number` - オフセット
- `startIndex: number` - 開始インデックス
- `endIndex: number` - 終了インデックス

#### 精度
- 整数値のみ

### 検索スコア計算（将来拡張用）

#### 計算式
```
score = titleMatch * 3 + contentMatch * 1 + categoryMatch * 2 + tagMatch * 2
```

#### 入力
- `titleMatch: boolean` - タイトルに一致
- `contentMatch: boolean` - 本文に一致
- `categoryMatch: boolean` - カテゴリに一致
- `tagMatch: boolean` - タグに一致

#### 出力
- `score: number` - 検索スコア

#### 精度
- 整数値のみ


